\section{Theory of Product Configuration}\label{sec: Theory of product configuration}
The aim of this chapter is to identify important aspects of product configuration along with a discussion on existing literature. This research serves as preliminary work to implement my own structure for a product configurator. \newline

Before doing so, it is important to gain a common understanding of product configuration and what is being discussed. A common understanding of configuration is important because a complex configuration task might be carried out over different systems that have to collaborate with each other \cite{fefrjastza03a}. First, I am going to define terminology, ontology, and knowledge acquisition. The main focus of this section will be the configuration knowledge representation and the modeling and solving of configuration. Afterward, I will briefly go over the topics interactive technology, configuration diagnosis, and reconfiguration. 

\subsection{Terminology}

In order to understand product configuration it is necessary to define the different terms and configuration-related vocabulary which I will be using in this thesis. A configuration is different from design because during the process no new components can be created. The components are rather connected in predefined ways \cite{brown98}. Important concepts are configuration (or product configuration), configuration problem or task, configuration (solution), and the configurator. \newline

\textbf{Configuration Problem}: The configuration problem (or configuration task) model is composed of the customer's requirements and the configuration knowledge base \cite{sonitisu01a} and describes possible configurations \cite{junker06a}. The knowledge base consists of components, component types, their properties with values and constraints \cite{hofestrybawo14a, sotimasu98a}. The goal of the configuration task is to find a product configuration that satisfies all constraints as well as the user requirements. However, if a valid configuration cannot be found, part of the configuration task is also to elaborate on failures \cite{junker06a}. The configuration knowledge base may contain a catalog in which technical and functional features of generic components and their relationships are listed. It also includes customer requirements about functional attributes that are required for the configuration \cite{junker06a}.\newline

\textbf{Configuration}: A (product) configuration is a set of customized components with attribute values and their relations that appear in the configuration model which satisfies all requirements being. This represents a valid product specification \cite{sotimasu98a, junker06a, fefaateruraz17a, sonitisu01a}. It is important that a configuration is always based on the possibilities of choice \cite{soinie99a}. The configuration solution satisfies all requirements and is a valid product specification. Syrj√§nen \cite{syrjanen99a} defines different types of configuration solutions. He distinguishes between \textit{exists-configuration}, \textit{query-configuration}, \textit{diagnose-configuration}, and \textit{valid-configuration}. The \textit{exists-configuration} answers the question of whether there is any valid configuration for the configuration model. With the \textit{query-configuration}, the author wants to find out whether a valid configuration exists that fulfills given requirements. When a configuration model lacks this and is unsatisfiable, the \textit{diagnose-configuration} should state why the requirements are not satisfied. The \textit{valid-configuration} solves the question of whether a configuration is valid and can be further split into three categories. In a valid configuration, all constraints of the configuration model are satisfied. A suitable configuration is not only valid but also satisfies the user requirements. The optimal configuration is suitable and in addition, an optimality-criterion is fulfilled. In the remainder of this thesis, I will refer to suitable configurations as configurations or configuration solutions only.   \newline 

\textbf{Configurator}: A configurator is a tool that represents the configuration task, constraints and may interact with the user \cite{jabogrma10a}. Independent from the domain or technique, the configurator must fulfill different requirements. It must reason about interactions of several components and detect cases in which not all requirements can be fulfilled by providing a diagnosis. Furthermore, it needs to be easy to maintain in the long-term by system operators (product managers, not programmers) who in addition should be able to create the model \cite{junker06a, tisonisu03a}. A configurator should be able to be updated and further developed. The system expert must be able to perform tests regarding the completeness and consistency of the tool. For web-based configurators, the definition can be further refined. In every step of the configuration, the user should be able to see what selections have been made. The user should on the one hand be guided through the configuration process, but on the other hand, also be able to deviate from the standard process. Finally, the configurator has to be accessible (ideally in the preferred language) to the user \cite{tisonisu03a}. 

\subsection{Ontology}

A configuration ontology helps to generate a general understanding of the concepts in configuration. In addition, they provide a structure for existing knowledge and make it able to share \cite{chjojoberi99a} among different configuration frameworks. For the ontology I first analyse the paper of Soininen et al. \cite{sotimasu98a} this concept is then extended by other approaches. 

\subsubsection{Initial Approach}
In 1998 Soininen et al. \cite{sotimasu98a} introduced an informal ontology for product configuration with the goal to create a general understanding which can be shared and reused by other researchers. The authors state that a configuration can be classified as either connection-based, structure-based, resource-based, and function-based approaches. They defined that the basic structure of a configuration concept consists of \textit{components}, \textit{component types}, \textit{inheritance-relations}, the \textit{partonomy} and \textit{constraints}. \newline

A \textit{component} represents possible parts of the final configured product. The domain is represented by a set of \textit{component types}. Those are the real world objects that may be in the configuration.
Components inherit properties from their component types. The inheritance-relation is based on the generalization-specialization taxonomy. A component can be a type of another domain component. \newline

Component types can be distinguished by their \textit{attributes}. From here on I use the words attributes and properties interchangeably. Properties are defined by a property name, a value type, and its necessity. A property can be defined as mandatory or optional: \textit{mandatory} when the property should have a value or \textit{optional} when there may be a value.\newline

\textit{Constraints} can be of different kinds and determine which components are selected during the configuration process to appear in the configuration solution. For a configuration to be satisfied all constraints must be met. Constraints can refer to functions, ports, resources, and structure(whole-part) and thus to all types of parts in a configuration.\newline

To further define the relation of components and types the authors introduced a \textit{partonomy} (whole-part-dependency) constraint, where the component type may be part of more than one part definition. Those part types can be restricted to further refine the part definition. A component type is indicated by the part type and their component individuals are permitted to appear in the configuration. The number of component individuals that occur as parts is specified by \textit{cardinality constraints}. Moreover, parts can either be exclusive or shared. A shared component can be part of more than one component individual and is usually an abstract instance in a real-world configuration such as production time, or a shared software. Exclusive parts on the other hand can only appear in one component individual. \newline

A \textit{resource constraint} is defined by one or more of the components being limited to a certain amount. Actions during a configuration process can use or refill a resource. The total price of a configured product can be seen as a resource constraint. Other examples are working time or in an industry context resources that are produced and used such as steel. If a resource is limited, the components that consume the resource can only be in the solution if they do not need more than the actual amount of the resource. A resource can never take on a negative value. The optimal solution in terms of the use of resources should be the final configuration solution. \newline

A \textit{default value} is used if the user does not specify a certain component type or attribute. It is important to note that a default value cannot be part of the solution if it is not compatible with the user requirements. If the user requests a component that requires another component (or attribute value) that is incompatible with the default value, the default value also cannot be in the assignment (transitive incompatibility). Mandatory and optional components both have default values even if the optional component is not in the final assignment.


\subsubsection{Extending Concepts}
The approach of Felfering et al. \cite{fefrjastza03a} corresponds with the ontology of Soinien et al. \cite{sotimasu98a} and uses the component-based approach, resource types (here: resource constraints), port types (here: port connections), and structures by a whole-part-relationship. They also adapted the generalization by graphical illustration. The authors showed that this ontology can solve configuration problems that are defined and solved using different approaches. Namely, the ontology can be applied to constraint-based systems with predicate logic and knowledge representation and reasoning (KRR) methods that are described by description logic. The authors also introduced \textit{dependencies} of components and special \textit{resources types} where some components consume, and others produce resources.  \newline

In 1999 Soinien et al. \cite{soinie99a} added requirements for configuration knowledge as a further step towards a general definition of product configurations. The authors identified four factors that must be included in any configuration knowledge: \textit{requirement, incompatibility, optional elements, default elements}. If one component or instance is present in a configuration, it might be the case that some component or set of elements is required for the configuration as well. In contrast to the require-constraint where components are only valid together, a knowledge base can also include incompatible instances which cannot be together in a configuration. A configured product can include optional elements which are not necessary, and the configuration would still be valid without them. If no specific component of a component type is chosen, there should be a default value that is chosen if not defined differently by the user. \newline

Junker \cite{junker06a} defines component-based systems over their components for configurations and defines them accordingly to previous literature based on their types, attributes, and parts. In addition, Junker introduces the idea of a \textit{configuration catalogue} with which the generic knowledge of components can be described. Acting as a counter thesis to Soinien et al. \cite{sotimasu98a}, Junker says that the structure of a configuration always depends on the applied domain. \newline

Taking a new perspective, Helo et al. \cite{hexukyji10a} focuses on the customer needs. In their ontology user preferences are turned into weighted constraints by which the product configurations are ranked. This is extended by \textit{DIYD} (\textit{do-it-yourself-design}) configuration where users can choose certain attributes for their product. As a result, the authors cover product and supply chain configuration as well as customer requirements. \newline

In 2014 Hotz et al.\cite{hofestrybawo14a} refines the incompatibility-definition of \cite{soinie99a} by saying, that either \textit{compatibility or incompatibility} should be modelled by choosing the one that appears less. The authors emphasise different \textit{constraints} for configurations which are graphical constraints, pricing constraints, resource constraints, require constraints, incompatibility constraints, and compatibility constraints. \newline

In conclusion, an ontology is important because it standardizes the vocabulary and concepts of configuration, whilst also providing a common understanding of the presented knowledge. All authors chose component-based configuration methods as those are seen as one of the most efficient ways to configure customized products for mass production \cite{shwalife06a}.That being said, solving mechanisms and optimization criteria have not yet been defined. In addition, the presented ontologies need to be validated and it is important to clarify, whether the configuration structure really depends on the product domain and cannot be applied independently as this is the actual goal of a general ontology. We also have different constraints defined by the research. Nevertheless, the graphical constraint seems to be made redundant by the other constraints. Constraint represented in a UML-diagram can be categorized as a pricing, resource, requirement, incompatibility, or compatibility constraints.

\subsection{Knowledge Acquisition}

Knowledge is the basis for any product configuration. Therefore, the process to obtain all the relevant knowledge is rather intensive and has to be gathered from different domains. Some knowledge domains involved are the bill of material (BOM), bill of functions (BOF), bill of operations (BOO), the planning process, the production process, and the customer requirements \cite{zhvaal13a}. The knowledge is usually represented as constraints and rules. These constraints and rules influence the configuration process and determine which component is chosen for the final product \cite{fefrjastza03a}. We can identify two main knowledge groups: the company‚Äôs knowledge, which may be contributed across several domains, and customer-related knowledge. While the company‚Äôs knowledge is rather straightforward to extract, customer knowledge is not fully discovered. It can be separated into customer requirements and intrinsic customer needs. Finding the customer needs and creating specific relationships towards the functional requirements can be done using data mining techniques \cite{shwalife06a}.  \newline

According to Zhang \cite{zhang14a}, the processes of getting configuration knowledge differs for distributed product configurations because companies apply different formats of documentation, while they also structure their knowledge in different ways. Another field for future research is the acquisition of implicit knowledge. So far research focused on explicit knowledge (knowledge that can be extracted from databases) but did not investigate enough in regards to implicit knowledge. Implicit knowledge is the knowledge that is stored in the minds of people. Being able to extract implicit knowledge is valuable for companies because it prevents knowledge from being lost if experienced employees or domain experts leave the company.

\subsection{Configuration Knowledge Representation}
Before a configuration problem can be solved, it needs to be represented in a way that captures the components, their attributes, and constraints like structural and user requirements. This is supposed to be used by different systems (and algorithms) and must be easy to maintain. As a result, it must be modular, expressive, declarative, optimizable, and capable of representing different reasoning methods \cite{mailharro98a}. We can define three groups of knowledge representations which are \textit{(1)} constraint-based knowledge representation, \textit{(2)} graphical knowledge representation and \textit{(3)} logic-based knowledge representation \cite{hofestrybawo14a}.

\subsubsection{Constraint-Based Knowledge Representation}
Two approaches have been particularly well established for constraint-based representations: constraint satisfaction problems (CSP) and satisfiability problems (SAT). Constraint-based technologies address knowledge acquisition as it often represents the bottleneck of a configuration problem. \newline

\textbf{CSP}: The CSP is represented by a triplet, (\textit{V,D,C}) where \textit{V} is a set of domain variables, D is the variable domain, and \textit{C} represents a set of constraints which can be refined according to the product configuration. There are two sets of constraints: the configuration knowledge and the customer requirements. If a complete solution can be found, each variable gets assigned a value from the domain in consideration of the constraints. This general definition of CSP is also called \textit{static CSP}. An advantage is, that it is easy to use and to understand \cite{hofestrybawo14a, dhfahata17a}. An extension of CSP is \textit{dynamic CSP}. In DCSP it is possible to activate and deactivate the variables of a configuration during the search process. As extension partonomies, inheritance relationships, ports, and component types are available \cite{mitfal90}. However, it is not ideal for product configuration as it is not component oriented. In addition, there are no standardized or modular concepts given and generative problem solving is not possible. Furthermore, size and structure of the model cannot be assessed in advance. To overcome these limitations the concept of \textit{generative constraint satisfaction problems} (GCSP) was introduced \cite{stfrha98, hofestrybawo14a}.  \newline


\textbf{SAT}: The goal of a satisfiability problem (SAT) is to evaluate whether a formula (in conjunctive normal form) is satisfiable and evaluates as true. Therefore, each variable has Boolean values. SAT is a model-based approach that allows efficient reasoning. Limitations of SAT for product configurations are that the representation is not component oriented and there are no standardized concepts for SAT. There are also no concepts available to structure or modularize the knowledge base and it is not possible to solve generative problems \cite{hofestrybawo14a}. \#SAT is an extension for SAT and more suitable for industrial configurations. However, more research is needed to determine whether \#SAT is scalable for large industrial systems \cite{suthsc20a}.
\newpage
\subsubsection{Graphical Knowledge Representation}

In the literature, two graphical approaches are mainly used for the representation of product configuration. One is the already mentioned UML class diagram, the other one is the feature diagram \cite{hofestrybawo14a, mytirafe14a}. \newline

\textbf{UML}: Mailharro \cite{mailharro98a} introduced a representation for configuration problems that is a combination of a classification problem and a CSP. He, therefore, uses the Unified Modelling Language (UML) and models the configuration problem as a UML class diagram. The classes represent the different components and the relations between those are the constraints which can be separated into three categories. First, we have a generalization that represents inheritance, where a component type inherits the attributes of the more general component. Further, the whole-part relation is shown as an aggregation (or composition) and last, the requires relation, where one component uses or needs another. In addition, component types are also stored in a catalogue. We can already see a similarity with the ontology of Soinien et al. \cite{sotimasu98a} for this approach. It was later taken up by other authors and refined in some cases \cite{fefrjastza03a, hofestrybawo14a}. Furthermore, Mailharro \cite{mailharro98a} states two rules for a type variable which is defined as a restricted variable that has a certain type. In a configuration, the component type represents a real world part of a product. Every configuration solution that is valid can only contain valid component types. In addition, for every sub component there must be a valid generalization. \newline

UML class diagrams represent component-based configuration problems in an easy and intuitive way where each class is a component type or its refinement. It is seen as an industry standard and is therefore usually understood by stakeholders. In addition, it can be easily translated into other languages or structures. The component types are defined by sets of attributes, multiplicities, and associations. Component types can be part of each other and inherit and specialize features by using generalizations. A leaf component type must always be explicit. With the help of this structure, different constraints can be represented graphically \cite{hofestrybawo14a}. UML can further be extended by \textit{SysML} which is a dialect of UML created for system engineering applications. The extension offers tools for systems for analysis, verification and validation, and design \cite{SysML}.\newline

\textbf{Feature Model}: The purpose of feature models is to represent how systems can be altered. They are particularly used to model the variability in software product lines and are therefore applicable for product configuration. Myll√§rniemi et al. \cite{mytirafe14a} argue that both disciplines pursue the same goal by managing the adaptability of a (software or physical) product. The feature model represents the structure and constraints of the configuration. A feature is a component that represents product properties. Component types are modelled as component types with attributes and constraints. Parts of component types are called sub components and can be mandatory, an alternative, or be optional. Furthermore, two components can be combined using the require constraint. The component types and sub components are defined by their attributes. According to Hotz et al. \cite{hofestrybawo14a}, UML class diagrams such as feature models are easy to understand and have a standardized semantic. However, feature models are under criticism for not being component-oriented and that no modularization concepts are available. \newline

UML class diagrams and feature models are tools to model platform independent models (PIM) which need to be translated into executable code to solve a configuration problem \cite{sommerville10a, zhmezhya05a}. Those graphical models do not contain any mechanism for automated consistency maintenance, and it is not possible to reason about the knowledge in an efficient way. Moreover, they are not able to solve generative problems for on-demand generation of components and their constraints. Finally, they do not support the production of explanation \cite{hofestrybawo14a}. 

\subsubsection{Logic-Based Knowledge Representation}

We can already conclude from this analysis that a graphical representation itself will not be able to solve a configuration problem. To represent the component types and structure a logic-based approach can be used. One logic-based method is the \textit{first-order logic} (FOL). UML modelling semantics can be directly translated into FOL by applying a decidable subset \cite{hofestrybawo14a}. FOL is not limited to UML diagrams and can also be used to validate feature models \cite{elphho09a}. \newline

A configuration problem and its configuration are represented by a triple consisting of knowledge base, requirements, and completeness axioms. A configuration qualifies as satisfiable if the configuration knowledge base, the customer requirements, and a given set of positive literals are satisfiable together \cite{hofestrybawo14a}. \newline

FOL is, however, rather limited to the representation of a configuration model. Therefore, we need another logic-based approach which can solve a configuration task. To achieve this the knowledge can be represented in \textit{Answer Set Programming} (ASP), a programming language that combines proficiency from knowledge representation, logical programming, and deductive databases. ASP is defined under stable-model semantics and is a subset of FOL. Modelling and solving configuration tasks in ASP is a widely used method and configuration as a real-world problem was even handled as one of the first applications in ASP. However, there is no standardized (graphical) concept for ASP. It is therefore a good idea to accompany an ASP model with a graphical UML or feature model which provides the graphical component and is an industry standard \cite{hofestrybawo14a}. 

\subsection{Configuration Modeling and Solving in ASP}
My research so far shows that the most suitable representation for configuration knowledge is the combination of two approaches: a graphical approach with a logic-based method. In literature, CSP is often used for configuration problems but it is not as fitting as ASP \cite{fefaateruraz17a}.

\subsubsection{Advantages of ASP}
Answer Set Programming provides various advantages for the representation and solving of configuration problems.
ASP is suitable for configuration tasks because it offers concepts for modularization.
Furthermore, knowledge can be represented based on a model and ASP is even able to provide an explanation which is needed for configuration diagnosis \cite{hofestrybawo14a}. Further, ASP supports the representation of hierarchies and declarative constraint relations. Because ASP cannot generate components purely during runtime, a predefinition of potential component individuals is necessary \cite{fefaateruraz17a}. This reflects the basic definition of configuration compared to design \cite{brown98}. An additional advantage is that ASP can be extended with optimization, aggregation, and default negation \cite{faryscsc15a}.

\subsubsection{Syntax and Semantics of ASP}

The encodings in normal ASP are logic programs which constitute rules of form 
\[
a_0 \texttt{ :- } a_1,\dots,a_m,\texttt{not } a_{m+1},\dots,\texttt{not } a_n.
\]
where each $a_i$ is an atom for $0\leq i \leq n$ and \texttt{not} stands for default negation.
If $n=0$, we refer to the rule as a \emph{fact}.
A negation-free normal rule is called \emph{definite}.
An \emph{integrity constraint} is a rule where $a_0$ is skipped.
The solution of answer set programs constitutes answer sets, whose semantics is given by \cite{gellif88b}.
\newline

For facilitating applications of ASP, several extensions have been developed.
One of them is the use of choice rules of the form:
\[\{a\}\texttt{ :- }.\]
where $a$ is an atom.
This can be seen as a choice, where $a$ may or may not be present in an answer set.
The semantics of answer set programs with choice rules is given by \cite{simons00a}.
\newline

The solving of an answer set program is carried out in two steps.
The first part is the \textit{grounding} where a propositional representation of the inserted program is generated.
Then, the answer sets of this program are computed by the solver. 
Even the solver \textit{clingo} is actually an aggregate of the grounder \textit{gringo} and the solver \textit{clasp} \cite{gekakasc14a}.

\subsubsection{Configuration in ASP}
There are various examples in academic literature for solving a configuration problem in ASP. Some authors even describe ASP as a natural fit for configuration \cite{sonitisu01a}. There are different examples for directly translating a feature model or a UML class diagram into ASP code \cite{mytirafe14a, hofestrybawo14a}. However, most examples for product configuration in ASP in literature are domain specific.\newline

To recap, we need an answer set program that can represent component types, component individuals, generalizations (inheritance), whole-part-relations, attributes, optional elements, default elements, and types for attribute values. In addition, the necessary constraints such as incompatibility, compatibility, resource, pricing, and require constraints must be defined. Therefore I analysed five approaches from different authors and compared, how they represented those requirements in ASP. To gain a brief overview, a comparison table can be found in the appendix. \newline  

In the first method, the authors translated UML class diagram notation into ASP \cite{hofestrybawo14a}. Therefore, they defined real world components (instances) which are defined as \text{name\_of\_component(X)} where X represents a number. The components are defined as facts and are additionally assigned to the type ‚Äúcomponent‚Äù using rules. The generalization and attribute assignment is also done in fact format. The authors did define a whole-part relationship. However, other necessary elements for a complete configuration are missing default elements, optional elements, (in-)compatibility rules, resource, price, and requirement constraints. \newline

To translate a feature model into an ASP encoding, the terminology is different from the one we used so far \cite{mytirafe14a}. A configuration is initiated with a root feature and has different feature types that are defined as facts. Attributes are defined as facts and assigned using choice rules. The same rules are used to define whole-part relations. In addition, requirement constraints and \textit{possible parts} are defined. Possible parts are compatible with a configuration or can be seen as optional elements, but the authors do not further define this. Again, we are missing some factors for a full representation of a configuration problem. \newline

Soininen et al. \cite{sonitisu01a} uses the ontology of \cite{sotimasu98a} to represent a computer and its configuration in ASP. Their focus is on weighted constraint rules for solving a configuration problem. In line with the other two approaches, the component individuals and types are defined in fact format. In contrast, the assignment of component individual to component type is done through an integrity rule and not by using the basic rule format. The whole-part relation is defined using choice rules, but the authors did not define the generalization or attributes. Constraints are generally defined by integrity constraints.\newline

Looking at a domain specific approach, Felfernig et al. \cite{fefaateruraz17a} configure a smart home with the help of ASP. Again, component types and their individuals are defined using fact format. The inheritance relationship is represented by a basic rule and an accommodating choice rule. Attribute domains are in fact format and assigned to their component types with choice rules. To define the attribute value, attributes are assigned a concrete value through basic rules. The authors define constraints and incompatibility rules through integrity rules. Customer requirements are set as facts and integrity rules. Requirements are represented by choice rules in ASP. The authors cover many of the above mentioned requirements. However, the configurator is dependent on the domain and cannot be used for other configuration problems without applying major changes.\newline

Gebser et al. \cite{gekakasc11d} are taking a different approach towards configuration in ASP. They mainly focus on optimization criteria to minimize or maximize sequences. The components are defined using fact format. The authors also included conflicts and dependencies using fact format which can be seen as incompatibility and require constraints. Even though some of the main requirements such as whole-part or inheritance relation are not provided, this paper can still be used as guidance for future work on the configurator to include optimization. \newline 

Looking at the literature so far, there are different approaches that can be used to create a configurator, but none of the reviewed papers include all requirements. In contrast to the first two papers, the aim of this thesis is not to translate a graphical representation of a configuration problem into executable code. The main artefact for the configuration is supposed to be the code which may be accompanied by some graphical explanation. However, some ideas like the use of a root component can be applied independently from a feature model representation. \newline 

It is also interesting that the format of certain facts or rules differs for the different approaches. Especially the part definitions differ regarding their format. Hotz et al. \cite{hofestrybawo14a} use tuples, Soininen et al. \cite{sonitisu01a} use triples and Myll√§rniemi et al. \cite{mytirafe14a} use triples and quadruples. All compared authors also have different approaches defining the requirements. They are represented using basic rules, choice rules, or integrity rules, respectively. 

\subsection{Interactive Configuration}

So far, we have not looked at customer interaction as it is not the focus of this work. However, customer interaction is an essential factor in the configuration process. Pereira et al. \cite{pemakrspsa17} separate the interactive configuration process into five categories: configuration, propagation of decisions, validation, calculation of recommendations, and visualization. According to Falkner et al. \cite{fahakrscscta20a}, two categories can be identified when looking at the interaction. One is the user interface (frontend) and the other is the backend which is represented by a KRR-system. In this section I will treat the words \textit{user} and \textit{customer} synonymously.

\subsubsection{Recommender System}
Looking at the backend there are a few requirements a configuration system should fulfill to guarantee a successful customer interaction \cite{fahakrscscta20a}. Users need to be able to delete or create configuration objects and to change attribute values during the configuration process. The configurator should enable the user to undo or unset earlier decisions. \newline

The configurator must be able to make suggestions for the user. This can be done by setting dynamic default values depending on the user's decision. For a successful configuration, the system should filter all invalid values and only show valid values for the user to choose from. The customer must be informed whether there is (at least) one possible solution for the current selection. The system should configure an optimal solution in terms of compatible components, user requirements, and other constraints. Dhungana et al. \cite{dhfahata17a} conclude, that an interactive product configuration system aims to provide options to customize a product and the ability to create the optimal product for the customer. 

\subsubsection{Configuration Diagnosis and Explanation} 

For successful user interaction, the configurator should inform the user if a configuration is not satisfiable. This procedure is called \textit{configuration diagnosis}. The diagnosis and user interaction are related because product constraints are seen as part of the knowledge base, whereas the user interaction or decision are seen as constraints that potentially cause conflicts \cite{fahakrscscta20a}.\newline

Syrj√§nen \cite{syrjanen00a} identifies three properties for a successful diagnosis. First, the problematic component(s) must be identified by the configurator. Second, there must be an explanation provided for every problematic component. The explanation should state why the specific component is necessary for the configuration. In the last property, the author describes that the diagnosis should be as precise as possible, only containing the necessary information. Whenever there is no suitable configuration, a diagnosis should be computed. According to  \cite{syrjanen99a}, when a diagnosis is required, there is more than one diagnostic model. It is usually enough to use the model with the fewest problems. Gen√ßay et al. \cite{gescer19a} show, that configuration diagnosis can be represented in ASP.

\subsection{Reconfiguration}

Especially for products with a long lifetime, reconfiguration should be considered when creating a new system. Reconfiguration is a part of the re-engineering process where new requirements must be satisfied by the existing configuration while different preferences are optimized. Therefore, reconfiguration is an extension of the product configuration process, where parts of an existing configuration are reused. Friedrich et al. \cite{frryfahascsc11} shows that ASP can represent this extension. \newline

Falkner et al. \cite{falhas13} defined seven challenges that occur when changing the knowledge base of the configurator for reconfiguration. For knowledge evolution, the knowledge base must be redesigned. To avoid regular changes of the knowledge base, values that change often should not be hardcoded (i.e., price). A change in the knowledge base involves a change in the scheme of the database to some extent. New integrated instances may violate existing constraints. Those contradictions must be solved for a successful reconfiguration. If a solver is domain-specific or some domain-dependent algorithm is involved, the solver might need to be adapted. For interactive configuration, the user interface has to be changed if required. In addition, input and output values may require changes, too. To validate the reengineered configurator applied test suites need to be adapted accordingly.